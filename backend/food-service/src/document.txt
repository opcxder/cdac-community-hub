

I'm building the Food Service for a microservices project called CDAC Community Hub. I need complete guidance from project setup to deployment, working INDEPENDENTLY first, then integrating with Auth Service later.

### PROJECT OVERVIEW

**What we're building:** A platform where CDAC students/employees discover and rate food places near campus.

**My responsibility:** Food Service - manages food categories, food places, ratings, reviews, and images.

**Timeline:** 7 days to complete

**Team setup:** 5-person team, each building one independent microservice. Auth Service is being built by another member - I'll integrate with it later using mock data first.

### TECH STACK (FIXED - NO ALTERNATIVES)

- **Framework:** Spring Boot 4.0.0 (latest stable as of Nov 2025)
- **Language:** Java 17 or Java 21
- **Build Tool:** Maven
- **Database:** MySQL 8.0 (database name: `food_db`)
- **ORM:** Hibernate/JPA
- **Image Storage:** Cloudinary (external, URLs stored in database)
- **Service Discovery:** Spring Cloud Eureka Client
- **API Documentation:** Springdoc OpenAPI 3.0 (Swagger UI)
- **Logger:** SLF4J with Logback
- **IDE:** Spring Tool Suite (STS) / Eclipse
- **Container:** Docker
- **Configuration:** application.properties (NOT yml)
- **Profiles:** dev, prod

### FOOD SERVICE RESPONSIBILITIES

**Core Features:**

1. **Category Management**
   - Users can create new categories (status = PENDING)
   - Admin approves categories (status = APPROVED)
   - Only approved categories visible to all
   - Dynamic: user creates category while submitting food place

2. **Food Place CRUD**
   - Users submit food places (status = PENDING)
   - Only approved places visible to public
   - Support multiple categories per place
   - One "best_for" category per place
   - Address fields: full address, city, locality, landmark, map link
   - Price range: Budget-friendly, Medium, Expensive

3. **Image Management**
   - Upload 1-5 images per food place to Cloudinary
   - Store Cloudinary URLs and public_ids in database
   - Delete images from Cloudinary when removed

4. **Rating System**
   - Simple 1-5 star rating
   - Optional review text
   - One rating per user per place (database constraint)
   - Calculate average rating

5. **Review Replies**
   - Users can reply to reviews
   - Thread-style discussions

6. **User Data Management (Phase 3+)**
   - Cache user data locally (user_cache table)
   - Call Auth Service to validate users (when ready)
   - Mock user data in dev profile (Phases 1-2)

7. **Internal APIs (for Admin Service)**
   - GET /internal/places/pending
   - POST /internal/places/{id}/approve
   - POST /internal/places/{id}/reject
   - GET /internal/categories/pending
   - POST /internal/categories/{id}/approve

### DATABASE SCHEMA (food_db)

**Table: user_cache**
```sql
CREATE TABLE user_cache (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    account_status VARCHAR(20),
    last_synced TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**Table: food_categories**
```sql
CREATE TABLE food_categories (
    category_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(100) UNIQUE NOT NULL,
    created_by_user_id BIGINT COMMENT 'No FK - references auth_db.users',
    status ENUM('PENDING', 'APPROVED', 'REJECTED') DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approved_at TIMESTAMP,
    INDEX idx_status (status),
    INDEX idx_name (category_name)
);
```

**Table: food_places**
```sql
CREATE TABLE food_places (
    place_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    place_name VARCHAR(200) NOT NULL,
    description TEXT,
    address TEXT NOT NULL,
    city VARCHAR(100),
    locality VARCHAR(200),
    landmark VARCHAR(200),
    map_location VARCHAR(500),
    contact_info VARCHAR(15),
    price_range ENUM('Budget-friendly', 'Medium', 'Expensive'),
    best_for_category_id BIGINT,
    submitted_by_user_id BIGINT NOT NULL COMMENT 'No FK - references auth_db.users',
    status ENUM('PENDING', 'APPROVED', 'REJECTED') DEFAULT 'PENDING',
    rejection_reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approved_at TIMESTAMP,
    FOREIGN KEY (best_for_category_id) REFERENCES food_categories(category_id),
    INDEX idx_status (status),
    INDEX idx_submitted_by (submitted_by_user_id)
);
```

**Table: food_place_categories** (many-to-many)
```sql
CREATE TABLE food_place_categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    place_id BIGINT NOT NULL,
    category_id BIGINT NOT NULL,
    UNIQUE KEY unique_place_category (place_id, category_id),
    FOREIGN KEY (place_id) REFERENCES food_places(place_id) ON DELETE CASCADE,
    FOREIGN KEY (category_id) REFERENCES food_categories(category_id) ON DELETE CASCADE
);
```

**Table: food_place_images**
```sql
CREATE TABLE food_place_images (
    image_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    place_id BIGINT NOT NULL,
    image_url VARCHAR(500) NOT NULL,
    cloudinary_public_id VARCHAR(255),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (place_id) REFERENCES food_places(place_id) ON DELETE CASCADE
);
```

**Table: food_place_ratings**
```sql
CREATE TABLE food_place_ratings (
    rating_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    place_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL COMMENT 'No FK - references auth_db.users',
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    review_text TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY unique_user_place_rating (place_id, user_id),
    FOREIGN KEY (place_id) REFERENCES food_places(place_id) ON DELETE CASCADE,
    INDEX idx_place (place_id),
    INDEX idx_user (user_id)
);
```

**Table: food_review_replies**
```sql
CREATE TABLE food_review_replies (
    reply_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rating_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL COMMENT 'No FK - references auth_db.users',
    reply_text TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (rating_id) REFERENCES food_place_ratings(rating_id) ON DELETE CASCADE,
    INDEX idx_rating (rating_id)
);
```

### PROJECT STRUCTURE
````
food-service/
├── src/main/java/com/cdac/food/
│   ├── FoodServiceApplication.java
│   ├── controller/
│   │   ├── CategoryController.java
│   │   ├── FoodPlaceController.java
│   │   ├── RatingController.java
│   │   ├── ImageController.java
│   │   └── InternalFoodController.java
│   ├── service/
│   │   ├── CategoryService.java
│   │   ├── FoodPlaceService.java
│   │   ├── RatingService.java
│   │   ├── ImageService.java
│   │   ├── UserCacheService.java
│   │   └── AuthServiceClient.java (interface)
│   ├── service/impl/
│   │   ├── MockAuthServiceClient.java (@Profile("dev"))
│   │   └── RealAuthServiceClient.java (@Profile("prod"))
│   ├── repository/
│   │   ├── CategoryRepository.java
│   │   ├── FoodPlaceRepository.java
│   │   ├── FoodPlaceCategoryRepository.java
│   │   ├── ImageRepository.java
│   │   ├── RatingRepository.java
│   │   ├── ReplyRepository.java
│   │   └── UserCacheRepository.java
│   ├── model/
│   │   ├── FoodCategory.java
│   │   ├── FoodPlace.java
│   │   ├── FoodPlaceCategory.java
│   │   ├── FoodPlaceImage.java
│   │   ├── FoodPlaceRating.java
│   │   ├── FoodReviewReply.java
│   │   └── UserCache.java
│   ├── dto/
│   │   ├── CategoryDTO.java
│   │   ├── FoodPlaceDTO.java
│   │   ├── FoodPlaceRequest.java
│   │   ├── RatingDTO.java
│   │   ├── RatingRequest.java
│   │   ├── ReplyDTO.java
│   │   └── UserDTO.java
│   ├── config/
│   │   ├── CloudinaryConfig.java
│   │   ├── RestTemplateConfig.java
│   │   ├── SwaggerConfig.java
│   │   └── CorsConfig.java
│   ├── exception/
│   │   ├── GlobalExceptionHandler.java
│   │   ├── ResourceNotFoundException.java
│   │   ├── DuplicateRatingException.java
│   │   └── UserNotFoundException.java
│   └── util/
│       └── Constants.java
├── src/main/resources/
│   ├── application.properties
│   ├── application-dev.properties
│   ├── application-prod.properties
│   ├── logback-spring.xml
│   └── data.sql (seed data for dev)
├── Dockerfile
├── pom.xml
└── README.md
REQUIRED DEPENDENCIES
Standard Spring Boot 4.0.0 dependencies PLUS:
xml
<!-- Cloudinary SDK -->
<dependency>
    <groupId>com.cloudinary</groupId>
    <artifactId>cloudinary-http44</artifactId>
    <version>1.38.0</version>
</dependency>
(All other dependencies same as Auth Service except JWT libraries)
CONFIGURATION FILES
application.properties:
properties
# Application
spring.application.name=food-service
server.port=8086

# Eureka
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=food-service

# Auth Service URL (for inter-service calls)
auth.service.url=http://localhost:8081

# Cloudinary
cloudinary.cloud-name=${CLOUDINARY_CLOUD_NAME:demo}
cloudinary.api-key=${CLOUDINARY_API_KEY:demo}
cloudinary.api-secret=${CLOUDINARY_API_SECRET:demo}

# File Upload
spring.servlet.multipart.max-file-size=5MB
spring.servlet.multipart.max-request-size=25MB

# Logging
logging.level.root=INFO
logging.level.com.cdac.food=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Swagger
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
application-dev.properties:
properties
# Use dev profile for standalone testing (no Auth Service needed)
spring.profiles.active=dev

# Database
spring.datasource.url=jdbc:mysql://localhost:3306/food_db?createDatabaseIfNotExist=true
spring.datasource.username=root
spring.datasource.password=root

# JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Mock mode (no real Auth Service calls)
auth.service.mock=true

# Logging
logging.level.com.cdac.food=DEBUG
application-prod.properties:
properties
spring.profiles.active=prod

# Database
spring.datasource.url=jdbc:mysql://food-db:3306/food_db
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}

# JPA
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false

# Real Auth Service
auth.service.url=http://auth-service:8081
auth.service.mock=false

# Logging
logging.level.com.cdac.food=INFO
DEVELOPMENT PHASES (7 DAYS)
IMPORTANT: Phases 1-2 work WITHOUT Auth Service using mock data. Phase 3+ adds Auth Service integration.
________________________________________
DAY 1: Project Setup & Database
Tasks:
1.	Create Spring Boot project with dependencies
2.	Setup MySQL database (food_db)
3.	Create all entity classes
4.	Create all repositories
5.	Test database connection
6.	Add seed data for dev (some approved categories)
Seed Data (data.sql):
sql
INSERT INTO food_categories (category_name, status, approved_at) VALUES
('Breakfast', 'APPROVED', NOW()),
('Lunch', 'APPROVED', NOW()),
('Dinner', 'APPROVED', NOW()),
('Tea/Coffee', 'APPROVED', NOW()),
('Snacks', 'APPROVED', NOW()),
('Biryani', 'APPROVED', NOW()),
('All-rounder', 'APPROVED', NOW());

-- Mock user cache for testing
INSERT INTO user_cache (user_id, username, email, account_status, last_synced) VALUES
(1, 'HappyPanda42', 'user1@test.com', 'APPROVED', NOW()),
(2, 'SmartTiger88', 'user2@test.com', 'APPROVED', NOW()),
(3, 'BraveLion99', 'user3@test.com', 'APPROVED', NOW());
Logger examples:
java
@Slf4j
public class FoodServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(FoodServiceApplication.class, args);
        log.info("Food Service started successfully on port 8086");
    }
}
Deliverables:
•	Project compiles
•	Database tables created with seed data
•	Can run application
________________________________________
DAY 2: Category & Food Place CRUD (NO Auth Service needed yet)
Tasks:
1.	Implement CategoryService and CategoryController 
o	Create category (set submitted_by_user_id from hardcoded value)
o	List approved categories
o	Get category by ID
2.	Implement FoodPlaceService and FoodPlaceController (basic) 
o	Create food place (use hardcoded userId = 1, 2, or 3)
o	List approved food places
o	Get food place by ID
o	Search by name
3.	Handle many-to-many relationship (food_place_categories)
At this stage: Use hardcoded user IDs (1, 2, 3) from seed data. No Auth Service calls yet.
API Endpoints:
POST /api/food/categories
Body: {
  "categoryName": "Momos"
}
Response: {
  "categoryId": 8,
  "categoryName": "Momos",
  "status": "PENDING"
}

GET /api/food/categories
Response: [
  { "categoryId": 1, "categoryName": "Breakfast", "status": "APPROVED" },
  ...
]

POST /api/food/places
Body: {
  "placeName": "Paradise Biryani",
  "description": "Best biryani in town",
  "address": "Himayat Nagar",
  "city": "Hyderabad",
  "priceRange": "Medium",
  "bestForCategoryId": 6,
  "categoryIds": [6, 5],
  "submittedByUserId": 1
}
Response: {
  "placeId": 1,
  "placeName": "Paradise Biryani",
  "status": "PENDING"
}

GET /api/food/places
Response: [
  {
    "placeId": 1,
    "placeName": "Paradise Biryani",
    "description": "Best biryani in town",
    "averageRating": 0,
    "submittedBy": "HappyPanda42"
  }
]
Logger examples:
java
log.info("Creating food category: {}", categoryName);
log.info("Food place submitted: placeId={}, name={}, submittedBy={}", placeId, placeName, userId);
log.debug("Fetching approved food places");
Note: At this stage, we're using hardcoded submitted_by_user_id. This is OK for testing!

DAY 3: Auth Service Integration (Mock + Real Clients)
Tasks:
1.	Create AuthServiceClient interface
2.	Implement MockAuthServiceClient (@Profile("dev"))
3.	Implement RealAuthServiceClient (@Profile("prod"))
4.	Implement UserCacheService
5.	Update FoodPlaceService to validate users
AuthServiceClient interface:
java
public interface AuthServiceClient {
    UserDTO getUserById(Long userId);
    boolean userExists(Long userId);
}
MockAuthServiceClient (dev profile):
java
@Service
@Profile("dev")
@Slf4j
public class MockAuthServiceClient implements AuthServiceClient {
    
    @Override
    public UserDTO getUserById(Long userId) {
        log.debug("Mock: Getting user by ID: {}", userId);
        
        // Return mock users for IDs 1, 2, 3
        if (userId <= 0 || userId > 3) {
            throw new UserNotFoundException("User not found: " + userId);
        }
        
        String[] usernames = {"HappyPanda42", "SmartTiger88", "BraveLion99"};
        String[] emails = {"user1@test.com", "user2@test.com", "user3@test.com"};
        
        return new UserDTO(
            userId,
            usernames[(int)(userId - 1)],
            emails[(int)(userId - 1)],
            "APPROVED"
        );
    }
    
    @Override
    public boolean userExists(Long userId) {
        log.debug("Mock: Checking if user exists: {}", userId);
        return userId >= 1 && userId <= 3; // Only users 1, 2, 3 exist
    }
}
RealAuthServiceClient (prod profile):
java
@Service
@Profile("prod")
@Slf4j
public class RealAuthServiceClient implements AuthServiceClient {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Value("${auth.service.url}")
    private String authServiceUrl;
    
    @Override
    public UserDTO getUserById(Long userId) {
        log.debug("Calling Auth Service: getUserById {}", userId);
        try {
            String url = authServiceUrl + "/internal/users/" + userId;
            UserDTO user = restTemplate.getForObject(url, UserDTO.class);
            log.info("Successfully fetched user from Auth Service: userId={}", userId);
            return user;
        } catch (Exception e) {
            log.error("Failed to fetch user from Auth Service: userId={}, error={}", 
                     userId, e.getMessage());
            throw new UserNotFoundException("User not found: " + userId);
        }
    }
    
    @Override
    public boolean userExists(Long userId) {
        log.debug("Calling Auth Service: userExists {}", userId);
        try {
            String url = authServiceUrl + "/internal/users/exists/" + userId;
            Boolean exists = restTemplate.getForObject(url, Boolean.class);
            log.debug("User exists check result: userId={}, exists={}", userId, exists);
            return exists != null && exists;
        } catch (Exception e) {
            log.error("Failed to check user existence: userId={}, error={}", 
                     userId, e.getMessage());
            return false;
        }
    }
}
UserCacheService:
java
@Service
@Slf4j
public class UserCacheService {
    
    @Autowired
    private UserCacheRepository cacheRepository;
    
    @Autowired
    private AuthServiceClient authServiceClient;
    
    public UserDTO getUserWithCache(Long userId) {
        // Check cache first
        Optional<UserCache> cached = cacheRepository.findById(userId);
        
        if (cached.isPresent() && !isStale(cached.get())) {
            log.debug("User found in cache: userId={}", userId);
            return UserDTO.from(cached.get());
        }
        
        // Cache miss or stale - fetch from Auth Service
        log.info("Cache miss for user: {}, fetching from Auth Service", userId);
        UserDTO user = authServiceClient.getUserById(userId);
        
        // Update cache
        updateCache(user);
        
        return user;
    }
    
    public boolean validateUserExists(Long userId) {
        // Quick check without caching
        return authServiceClient.userExists(userId);
    }
    
    private boolean isStale(UserCache cache) {
        long hoursSinceSync = Duration.between(
            cache.getLastSynced().toLocalDateTime(),
            LocalDateTime.now()
        ).toHours();
        return hoursSinceSync > 24;
    }
    
    private void updateCache(UserDTO user) {
        UserCache cache = new UserCache();
        cache.setUserId(user.getUserId());
        cache.setUsername(user.getUsername());
        cache.setEmail(user.getEmail());
        cache.setAccountStatus(user.getAccountStatus());
        cache.setLastSynced(Timestamp.valueOf(LocalDateTime.now()));
        
        cacheRepository.save(cache);
        log.debug("Updated user cache: userId={}", user.getUserId());
    }
}
Update FoodPlaceService:
java
@Service
@Slf4j
public class FoodPlaceService {
    
    @Autowired
    private FoodPlaceRepository foodPlaceRepository;
    
    @Autowired
    private AuthServiceClient authServiceClient;
    
    @Autowired
    private UserCacheService userCacheService;
    
    public FoodPlaceDTO createFoodPlace(FoodPlaceRequest request, Long userId) {
        log.info("Creating food place: name={}, submittedBy={}", 
                request.getPlaceName(), userId);
        
        // Validate user exists
        if (!authServiceClient.userExists(userId)) {
            log.error("User validation failed: userId={}", userId);
            throw new UserNotFoundException("User not found: " + userId);
        }
        
        // Create food place
        FoodPlace place = new FoodPlace();
        place.setPlaceName(request.getPlaceName());
        place.setDescription(request.getDescription());
        place.setAddress(request.getAddress());
        place.setCity(request.getCity());
        place.setLocality(request.getLocality());
        place.setLandmark(request.getLandmark());
        place.setMapLocation(request.getMapLocation());
        place.setContactInfo(request.getContactInfo());
        place.setPriceRange(request.getPriceRange());
        place.setBestForCategoryId(request.getBestForCategoryId());
        place.setSubmittedByUserId(userId);
        place.setStatus(PlaceStatus.PENDING);
        
        FoodPlace saved = foodPlaceRepository.save(place);
        
        // Cache user info
        UserDTO user = userCacheService.getUserWithCache(userId);
        
        log.info("Food place created successfully: placeId={}, name={}", 
                saved.getPlaceId(), saved.getPlaceName());
        
        return FoodPlaceDTO.from(saved, user.getUsername());
    }
}
Testing:
•	Dev profile: Uses mock client (users 1, 2, 3 always exist)
•	Prod profile: Makes real HTTP calls to Auth Service
________________________________________
DAY 4: Cloudinary Integration
Tasks:
1.	Configure Cloudinary
2.	Implement ImageService
3.	Create image upload endpoint
4.	Create image delete endpoint
CloudinaryConfig:
java
@Configuration
@Slf4j
public class CloudinaryConfig {
    
    @Value("${cloudinary.cloud-name}")
    private String cloudName;
    
    @Value("${cloudinary.api-key}")
    private String apiKey;
    
    @Value("${cloudinary.api-secret}")
    private String apiSecret;
    
    @Bean
    public Cloudinary cloudinary() {
        Map<String, String> config = new HashMap<>();
        config.put("cloud_name", cloudName);
        config.put("api_key", apiKey);
        config.put("api_secret", apiSecret);
        
        Cloudinary cloudinary = new Cloudinary(config);
        log.info("Cloudinary configured with cloud_name: {}", cloudName);
        return cloudinary;
    }
}
ImageService:
java
@Service
@Slf4j
public class ImageService {
    
    @Autowired
    private Cloudinary cloudinary;
    
    @Autowired
    private ImageRepository imageRepository;
    
    @Autowired
    private FoodPlaceRepository foodPlaceRepository;
    
    public List<String> uploadImages(Long placeId, MultipartFile[] files) {
        log.info("Uploading {} images for place: {}", files.length, placeId);
        
        FoodPlace place = foodPlaceRepository.findById(placeId)
            .orElseThrow(() -> new ResourceNotFoundException("Place not found"));
        
        List<String> imageUrls = new ArrayList<>();
        
        for (MultipartFile file : files) {
            try {
                // Upload to Cloudinary
                Map uploadResult = cloudinary.uploader().upload(
                    file.getBytes(),
                    ObjectUtils.asMap(
                        "folder", "cdac/food",
                        "resource_type", "image"
                    )
                );
                
                String imageUrl = (String) uploadResult.get("secure_url");
                String publicId = (String) uploadResult.get("public_id");
                
                // Save to database
                FoodPlaceImage image = new FoodPlaceImage();
                image.setPlaceId(placeId);
                image.setImageUrl(imageUrl);
                image.setCloudinaryPublicId(publicId);
                imageRepository.save(image);
                
                imageUrls.add(imageUrl);
                log.info("Image uploaded successfully: placeId={}, url={}", placeId, imageUrl);
                
            } catch (IOException e) {
                log.error("Failed to upload image for place {}: {}", placeId, e.getMessage());
                throw new RuntimeException("Image upload failed", e);
            }
        }
        
        return imageUrls;
    }
    
    public void deleteImage(Long imageId) {
        FoodPlaceImage image = imageRepository.findById(imageId)
            .orElseThrow(() -> new ResourceNotFoundException("Image not found"));
        
        try {
            // Delete from Cloudinary
            cloudinary.uploader().destroy(image.getCloudinaryPublicId(), 
                                         ObjectUtils.emptyMap());
            
            // Delete from database
            imageRepository.delete(image);
            
            log.info("Image deleted successfully: imageId={}, publicId={}", 
                    imageId, image.getCloudinaryPublicId());
        } catch (IOException e) {
            log.error("Failed to delete image from Cloudinary: {}", e.getMessage());
            throw new RuntimeException("Image deletion failed", e);
        }
    }
}
API Endpoints:
POST /api/food/places/{placeId}/images
Content-Type: multipart/form-data
Body: images (1-5 files)
Response: {
  "imageUrls": [
    "https://res.cloudinary.com/demo/image/upload/v1234/cdac/food/abc.jpg",
    "https://res.cloudinary.com/demo/image/upload/v1234/cdac/food/def.jpg"
  ]
}

DELETE /api/food/images/{imageId}
Response: {
  "message": "Image deleted successfully"
}
________________________________________
DAY 5: Rating & Review System
Tasks:
1.	Implement RatingService
2.	Create rating submission endpoint
3.	Calculate average rating
4.	Implement reply functionality
RatingService:
java
@Service
@Slf4j
public class RatingService {
    
    @Autowired
    private RatingRepository ratingRepository;
    
    @Autowired
    private FoodPlaceRepository placeRepository;
    
    @Autowired
    private AuthServiceClient authServiceClient;
    
    @Autowired
    private ReplyRepository replyRepository;
    
    public RatingDTO ratePlace(Long placeId, Long userId, RatingRequest request) {
     
        log.info("User {} rating place {}: rating={}", userId, placeId, request.getRating());
        
        // Validate user exists
        if (!authServiceClient.userExists(userId)) {
            log.error("Rating failed - user not found: userId={}", userId);
            throw new UserNotFoundException("User not found");
        }
        
        // Validate place exists and is approved
        FoodPlace place = placeRepository.findById(placeId)
            .orElseThrow(() -> new ResourceNotFoundException("Place not found"));
        
        if (place.getStatus() != PlaceStatus.APPROVED) {
            log.error("Rating failed - place not approved: placeId={}", placeId);
            throw new IllegalStateException("Cannot rate pending or rejected place");
        }
        
        // Check if user already rated this place
        if (ratingRepository.existsByPlaceIdAndUserId(placeId, userId)) {
            log.error("Rating failed - duplicate rating: placeId={}, userId={}", placeId, userId);
            throw new DuplicateRatingException("You have already rated this place");
        }
        
        // Create rating
        FoodPlaceRating rating = new FoodPlaceRating();
        rating.setPlaceId(placeId);
        rating.setUserId(userId);
        rating.setRating(request.getRating());
        rating.setReviewText(request.getReviewText());
        
        FoodPlaceRating saved = ratingRepository.save(rating);
        
        log.info("Rating created successfully: ratingId={}, placeId={}, userId={}, rating={}", 
                saved.getRatingId(), placeId, userId, request.getRating());
        
        return RatingDTO.from(saved);
    }
    
    public Double getAverageRating(Long placeId) {
        Double avg = ratingRepository.calculateAverageRating(placeId);
        log.debug("Average rating for place {}: {}", placeId, avg);
        return avg != null ? avg : 0.0;
    }
    
    public ReplyDTO addReply(Long ratingId, Long userId, String replyText) {
        log.info("User {} replying to rating {}", userId, ratingId);
        
        // Validate user exists
        if (!authServiceClient.userExists(userId)) {
            throw new UserNotFoundException("User not found");
        }
        
        // Validate rating exists
        if (!ratingRepository.existsById(ratingId)) {
            throw new ResourceNotFoundException("Rating not found");
        }
        
        FoodReviewReply reply = new FoodReviewReply();
        reply.setRatingId(ratingId);
        reply.setUserId(userId);
        reply.setReplyText(replyText);
        
        FoodReviewReply saved = replyRepository.save(reply);
        
        log.info("Reply created successfully: replyId={}, ratingId={}", 
                saved.getReplyId(), ratingId);
        
        return ReplyDTO.from(saved);
    }
}



RatingRepository (add custom query):
java
public interface RatingRepository extends JpaRepository<FoodPlaceRating, Long> {
    
    boolean existsByPlaceIdAndUserId(Long placeId, Long userId);
    
    List<FoodPlaceRating> findByPlaceIdOrderByCreatedAtDesc(Long placeId);
    
    @Query("SELECT AVG(r.rating) FROM FoodPlaceRating r WHERE r.placeId = :placeId")
    Double calculateAverageRating(@Param("placeId") Long placeId);
}
API Endpoints:
POST /api/food/places/{placeId}/rate
Body: {
  "rating": 4,
  "reviewText": "Great biryani, good portion size"
}
Response: {
  "ratingId": 1,
  "rating": 4,
  "reviewText": "Great biryani, good portion size",
  "createdAt": "2025-12-18T10:30:00"
}

GET /api/food/places/{placeId}/ratings
Response: [
  {
    "ratingId": 1,
    "rating": 4,
    "reviewText": "Great biryani",
    "username": "HappyPanda42",
    "createdAt": "2025-12-18T10:30:00",
    "replies": [
      {
        "replyId": 1,
        "username": "SmartTiger88",
        "replyText": "I agree! Try the chicken biryani",
        "createdAt": "2025-12-18T11:00:00"
      }
    ]
  }
]

POST /api/food/ratings/{ratingId}/reply
Body: {
  "replyText": "I agree! The chicken biryani is amazing"
}
________________________________________
DAY 6: Internal APIs & Pagination
Tasks:
1.	Create InternalFoodController for Admin Service
2.	Implement pagination for food places list
3.	Add search and filter functionality
4.	Complete error handling
InternalFoodController:
java
@RestController
@RequestMapping("/internal/food")
@Slf4j
public class InternalFoodController {
    
    @Autowired
    private FoodPlaceService foodPlaceService;
    
    @Autowired
    private CategoryService categoryService;
    
    @GetMapping("/places/pending")
    public ResponseEntity<List<FoodPlaceDTO>> getPendingPlaces() {
        log.info("Admin fetching pending food places");
        List<FoodPlaceDTO> pending = foodPlaceService.getPendingPlaces();
        return ResponseEntity.ok(pending);
    }
    
    @PostMapping("/places/{id}/approve")
    public ResponseEntity<Map<String, String>> approvePlace(@PathVariable Long id) {
        log.info("Admin approving food place: {}", id);
        foodPlaceService.approvePlace(id);
        return ResponseEntity.ok(Map.of("message", "Food place approved successfully"));
    }
    
    @PostMapping("/places/{id}/reject")
    public ResponseEntity<Map<String, String>> rejectPlace(
            @PathVariable Long id,
            @RequestBody Map<String, String> body) {
        String reason = body.get("reason");
        log.info("Admin rejecting food place {}: reason={}", id, reason);
        foodPlaceService.rejectPlace(id, reason);
        return ResponseEntity.ok(Map.of("message", "Food place rejected"));
    }
    
    @GetMapping("/categories/pending")
    public ResponseEntity<List<CategoryDTO>> getPendingCategories() {
        log.info("Admin fetching pending categories");
        List<CategoryDTO> pending = categoryService.getPendingCategories();
        return ResponseEntity.ok(pending);
    }
    
    @PostMapping("/categories/{id}/approve")
    public ResponseEntity<Map<String, String>> approveCategory(@PathVariable Long id) {
        log.info("Admin approving category: {}", id);
        categoryService.approveCategory(id);
        return ResponseEntity.ok(Map.of("message", "Category approved successfully"));
    }
    
    @PostMapping("/categories/{id}/reject")
    public ResponseEntity<Map<String, String>> rejectCategory(@PathVariable Long id) {
        log.info("Admin rejecting category: {}", id);
        categoryService.rejectCategory(id);
        return ResponseEntity.ok(Map.of("message", "Category rejected"));
    }
}
Pagination in FoodPlaceController:
java
@GetMapping("/places")
public ResponseEntity<Page<FoodPlaceDTO>> getPlaces(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size,
        @RequestParam(required = false) String search,
        @RequestParam(required = false) String priceRange,
        @RequestParam(required = false) Long categoryId) {
    
    log.info("Fetching food places: page={}, size={}, search={}, priceRange={}, categoryId={}", 
             page, size, search, priceRange, categoryId);
    
    Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());
    Page<FoodPlaceDTO> places = foodPlaceService.searchPlaces(search, priceRange, categoryId, pageable);
    
    return ResponseEntity.ok(places);
}
________________________________________
DAY 7: Testing, Documentation
Tasks:
1.	Complete Swagger documentation
2.	Write unit tests
3.	Test all flows: 
o	Create category → approve → create place with that category
o	Upload images
o	Rate place
o	Reply to review

5.	Test with both dev and prod profiles
6.	Integration testing


Testing Checklist:
•	Can create categories (pending status)
•	Can create food places (pending status)
•	Can upload images to Cloudinary
•	Can rate approved places (one rating per user)
•	Cannot rate same place twice (unique constraint works)
•	Can reply to reviews
•	Average rating calculates correctly
•	Pagination works
•	Search and filters work
•	Internal APIs work for admin
•	Dev profile uses mock Auth Service client
•	Prod profile makes real Auth Service calls
•	User cache works correctly
•	All error responses follow standard format
•	Logging is comprehensive
•	Swagger UI shows all endpoints
•	Docker image builds and runs
Logger examples for testing:
java
log.info("=== TESTING FOOD PLACE CREATION ===");
log.info("Test result: place created with ID {}", placeId);
log.info("=== TEST PASSED ===");
________________________________________
PROFILE SWITCHING
Run with dev profile (standalone, no Auth Service):
bash
mvn spring-boot:run -Dspring-boot.run.profiles=dev
Run with prod profile (requires Auth Service running):
bash
mvn spring-boot:run -Dspring-boot.run.profiles=prod
Docker with profiles:
bash
docker run -e SPRING_PROFILES_ACTIVE=prod food-service
________________________________________
SUCCESS CRITERIA
Your Food Service is complete when:
1.	✅ All CRUD operations work
2.	✅ Categories can be created and approved
3.	✅ Food places can be submitted and approved
4.	✅ Images upload to Cloudinary successfully
5.	✅ Rating system works (one rating per user per place)
6.	✅ Review replies work

8.	✅ Internal APIs work for Admin Service
9.	✅ Dev profile works standalone with mock data
10.	✅ Prod profile integrates with Auth Service
11.	✅ User cache mechanism works
12.	✅ Logging is comprehensive
13.	✅ Error handling is consistent
14.	✅ Swagger documentation complete

16.	✅ Eureka registration works
________________________________________
WHAT TO PROVIDE ME
1.	Complete pom.xml with Spring Boot 4.0.0 and Cloudinary
2.	Step-by-step setup in STS/Eclipse
3.	All entity classes with relationships
4.	Mock and Real AuthServiceClient implementations
5.	User cache mechanism (when to fetch, when to use cache)
6.	Cloudinary integration (upload, delete, URL storage)
7.	Rating system with duplicate prevention
8.	Pagination implementation
9.	Internal APIs for Admin Service
10.	Profile-based configuration (dev vs prod)
11.	Complete error handling
12.	Logger usage in all layers
13.	Swagger configuration

15.	Testing strategies
________________________________________
IMPORTANT NOTES
Database:
•	food_db - completely separate from auth_db
•	No foreign key constraints to auth_db.users
•	User validation via API calls to Auth Service
Development Strategy:
•	Days 1-2: Build standalone (no Auth Service needed)
•	Day 3: Add Auth Service integration with profiles
•	Days 4-7: Complete features and test both profiles
Mock vs Real:
•	Dev profile: Mock client returns hardcoded users 1, 2, 3
•	Prod profile: Real client makes HTTP calls to Auth Service
•	Switch profiles seamlessly with no code changes
Images:
•	Stored in Cloudinary, NOT in database
•	Database stores URLs and public_ids only
•	Multiple images per food place supported
User Cache:
•	Reduces Auth Service calls
•	Refreshes every 24 hours
•	Falls back to stale cache if Auth Service is down
Constraints:
•	Use application.properties (NOT yml)
•	Use SLF4J logger with @Slf4j
•	Follow error response standard
•	All endpoints in Swagger
•	Code must be clean and commented

